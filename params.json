{"name":"octo","tagline":"A Single Header Library for GCC C","body":"[octo]() - A GCC C Library\r\n========================================\r\n[![Build Status](https://drone.io/github.com/shrimpboyho/octo/status.png)](https://drone.io/github.com/shrimpboyho/octo/latest)\r\n\r\nA library for doing various things in C\r\n\r\nHow to Install\r\n--------------\r\n\r\nFirst get a copy of the library by git cloning it:\r\n\r\n```bash\r\ngit clone https://github.com/shrimpboyho/octo.git\r\ncd octo\r\n```\r\n\r\nThen you can just include the header file in your code:\r\n\r\n```c\r\n#include \"octo.h\"\r\n```\r\n\r\nDocumentation Regarding Strings\r\n-------------------------------\r\n###Get info on a string\r\n\r\n```c\r\nsize_t len(char* thing);\r\n```\r\n\t\r\nReturns the number of characters in ```thing``` excluding the null character.\r\n\r\n```c\r\nchar charAt(char* s, int n);\r\n```\r\n\r\nReturns the character in the string ```s``` at the index of ```n```\r\n\r\n###Make an identical copy of a string\r\n\r\n```c\r\nchar* makeCopy(char* thing);\r\n```\r\n\r\nCreates a new copy of ```thing``` in the memory and returns a pointer to it.\r\n\r\n###Modify the original string\r\n\r\n```c\r\nvoid* strip(char* thing);\r\n```\r\n\t\r\nTrims off both leading and trailing whitespace on ```thing```. It modifies the original buffer.\r\n\r\n```c\r\nvoid* lstrip(char* thing);\r\n```\r\n\t\r\nTrims off only the leading whitespace on ```thing```. It modifies the original buffer.\r\n\r\n```c\r\nvoid* rstrip(char* thing);\r\n```\r\n\t\r\nTrims off only the trailing whitespace on ```thing```. It modifies the original buffer.\r\n\r\n###Create new versions of strings\r\n\r\n```c\r\nchar* slice(char* thing, int start, int end, int BYTES);\r\n```\r\n\t\r\nCreates a new string from ```thing``` that consists of the characters from the starting index (```start```), to the ending index (```end```), and returns a ```char*``` to it. It does not modify the original buffer. The argument ```BYTES``` is usually zero if you want the returned string to perfectly fit in the buffer. If you plan on modifying the string after you get it from this function, it is best to set ```BYTES``` to some other value, such as 30, giving you 30 bytes of additional padding.\r\n```c\r\nchar* replaceBetween(char* s, int start, int end, char* ham);\r\n```\r\n\r\nReplaces the content of the string ```s``` between the indexes of ```start``` and ```end``` with the content of the string ```ham```. Returns a pointer to the new buffer.\r\n\r\n```c\r\nchar* toUpperCase(char* s);\r\n```\r\n\r\nCreates a new copy of ```s``` in which all the characters are uppercase and returns a pointer to it.\r\n\r\n```c\r\nchar* toLowerCase(char* s);\r\n```\r\n\r\nCreates a new copy of ```s``` in which all the characters are lowercase and returns a pointer to it.\r\n\r\n\r\n###Convert between strings and other data types\r\n\r\n```c\r\nint stringToInt(char* s);\r\n```\r\n\r\nConverts ```s``` to an integer and returns it.\r\n\r\n```c\r\nchar* intToString(int n);\r\n```\r\n\r\nConverts ```n``` to a string and returns a pointer to it.\r\n\r\nDocumentation Regarding WUMBO\r\n-----------------------------------------\r\n\r\n```wumbo``` is the simple math expression parser that comes packaged with ```octo```. ```wumbo``` parses a math expression contained within a string and returns the result as a double. The following code outlines how it is generally used. Note that since this module is not complete, although it functions, there may be memory leaks.\r\n\r\n```c\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include \"octo.h\"\r\n\r\nint main( void ){\r\n\r\n    double answer = WUMBO_parse(\"2 + ( 2 / 3 )\");\r\n    printf(\"\\nAnswer: %lf\\n\", answer);\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\nDocumentation Regarding The JSON Database\r\n-----------------------------------------\r\nThe following code shows how the database API basically works.\r\n\r\n```c\r\n#include \"database.h\"\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n/* Define how greedy you want octo to be with memory */\r\n#define DEPTH 20\r\n\r\nint main ( void )\r\n{\r\n\r\n    /* Create a database */\r\n    DB *bank = newDB(\"Employees\");\r\n    printf(\"Name of db is: %s\", bank -> name);\r\n    addValue(bank, \"Daniel\", \"Programmer\", STRING_TYPE);\r\n    addValue(bank, \"Kevin\", \"Hardware\", STRING_TYPE);\r\n    \r\n    /* Create another database*/\r\n    DB *money = newDB(\"Money\");\r\n    addValue(money, \"Monday\", \"5\", NUM_TYPE);\r\n    addValue(money, \"Tuesday\", \"7\", NUM_TYPE);\r\n\r\n    /* Shove the money database in the bank */\r\n    addDB(bank,money);\r\n\r\n    /* Pretty print the entire database*/\r\n    prettyPrint(bank);\r\n\r\n    /* Dump database contents to json file */\r\n    dumpDB(bank, \"bank.json\");\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n```octo``` currently has very limited JSON database support and functionality. For now, one can dump JSON contents to a file after building the file via the API. Note that within ```octo``` the term ```DB``` (database) is synonymous with the term ```JSON Document```\r\n\r\n####A Word on Memory\r\n\r\n```octo``` uses ```malloc()``` and ```free()``` to create format strings of variable size, for the purposes of printing in a nice formatted manner. The reason we do this is so that JSON within JSON can be properly tabulated. This means that we must build up a format string with a lot of tabs depending on how much depth a JSON file has.\r\n\r\nThere is one constant known as ```DEPTH``` which is a number. By default it is 20 bytes. It is recommended that ```DEPTH``` be at least 20 bytes. However, one can redefine it to be bigger.\r\n\r\n```c\r\n#define DEPTH 2323\r\n```\r\n\r\n####Simple Database Creation\r\n\r\nCreating a database is simple and can be done by invoking the following function:\r\n\r\n```c\r\n/* Create an empty database */\r\nDB *bank = newDB(\"Employees\");\r\n```\r\n\r\nThe JSON document is represented as such:\r\n\r\n```JSON\r\n{\r\n    \"Employees\" : {\r\n    \r\n    }\r\n}\r\n```\r\n\r\nFrom here one can access the JSON document name:\r\n\r\n```c\r\nchar *dbname = bank -> name;\r\nprintf(\"Name of db is: %s\", dbname);\r\n\r\n/** OUTPUT:\r\n*\tName of db is: Employees\r\n*/\r\n```\r\n\r\n####Adding Data To A Database\r\n\r\nAdding a simple key value pair can be done by calling the following function:\r\n\r\n```c\r\nDB *money = newDB(\"Money\");\r\naddValue(money, \"Monday\", \"5\", NUM_TYPE);\r\n```\r\nThe above code adds the value of ```5``` with the key of ```\"Monday\"``` to the database known as ```money```. Notice the fourth argument is a constant that specifies that the value of ```5``` is to be interpretted as a number rather than as a string.\r\n\r\nThere are several type constants you can use as arguments to the ```addValue()``` function:\r\n\r\n```c\r\nNUM_TYPE /* For all types of numbers, decimal and floating point */\r\nSTRING_TYPE /* For strings */\r\nBOOL_TYPE /* For true and false booleans */\r\nARRAY_TYPE /* For array types */\r\n```\r\n\r\n####Adding JSON inside of JSON\r\n\r\nThis is as simple as adding a database to another database. The ```addDB()``` function takes two arguments: the destination database and the source database.\r\n\r\n```c\r\n/* Create a database */\r\nDB *bank = newDB(\"Employees\");\r\n\r\n/* Create another database*/\r\nDB *money = newDB(\"Money\");\r\n\r\n/* Shove the money database in the bank database */\r\naddDB(bank, money);\r\n```\r\n\r\n####Deleting Stuff\r\n\r\nAnything within a database can be deleted if you know the key. The following code shows how the value associated with the key of ```Nash``` can be deleted from the database.\r\n\r\n```c\r\ndeleteByID(bank, \"Nash\");\r\n```\r\n\r\nNote that you can also delete an entire database within a database in the same manner. For example, the following code removes the database known as ```Money```:\r\n\r\n```c\r\ndeleteByID(bank, \"Money\");\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}